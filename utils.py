# Utilities, including data loading, generating labels

from __future__ import division
import numpy as np
import pdb
import math
import random
import csv
import pickle
import glob
from sklearn import preprocessing
import os


def load_pickle(filename, max_N = -1, scale = False):
    """
        Load the VLAD features generated by VLAD
    """
    load_data = pickle.load(open(filename, 'r'))
    if len(load_data)>1:
        X = load_data[1]
    else:
        X = load_data[0]
    X = np.asarray(X)
    if max_N > 0:
        X = X[0:max_N, :]
    if scale:
        X = preprocessing.scale(X)   
    return X
 
    
    
def gen_labels (N, periods):

    n_classifiers = len(periods)
    all_labels = np.zeros(shape=(N, n_classifiers), dtype='int') # The matrix to store labels for the classifier
    
    # Use recursion to generate the labels
    for i in range(1, N):

        all_labels[i,:] = all_labels[i-1, :]
        j = n_classifiers - 1
        
        while all_labels[i,j] == periods[j]-1:
            j -= 1
        
        all_labels[i,j] += 1
        for k in range(j+1, n_classifiers):
            all_labels[i, k] = 0

    return all_labels



def gcd(x, y):
 
   while(y):
       x, y = y, x % y
   return x
   
def lcm(a):
    """
    Largest common multiplier
    """
    l = 1
    for i in range(len(a)):
        l = l*a[i]/(gcd(l,a[i]))
    return l

def is_prime(a):
    """
        Check if a is a prime number
    """
    return all(a % i for i in range(2,  np.ceil(math.sqrt(a)).astype(int)+1) )

def closest_prime(a):
    """
        Find a prime that is closest to the given number
    """
    b = np.floor(a).astype(int)
    while not is_prime(b):
        b +=1 
    return b

def prime_factorization(n):
    """
        Factorize a number into prime numbers. Not that this has been modified to fit the need of the application
    """
    # Modify a little 
    primes=[]
    i = 2
    while i*i <= n:
        d = 1
        while n % i == 0:               
            d *= i    
            n = n // i
        if d>1:
            primes += [d]
        i += 1
    if n>1:
        primes += [n]
    return primes


def find_periods(n, n_patterns):
    # Factorize n to get the prime numbers
    p = prime_factorization(n)
    #print p
    n_patterns = min(n_patterns, len(p))
    k = int(np.floor(len(p)/n_patterns))
    periods = []
    start_idx = 0
    
    m = int(pow(n, 1/n_patterns))
    for i in range(n_patterns):        
        end_idx = start_idx
        d = p[end_idx]
        stop = len(p) - (n_patterns -1) -1
        while d < m and end_idx < stop:
            end_idx += 1
            d *= p[end_idx]
        start_idx = end_idx + 1    
        periods += [d]
        
    #print lcm(periods)
    return periods

    

def load_xvecs(filename, base_type='f', max_num=None):
    """
    A helper to read in sift1m binary dataset. This parses the
    binary format described at http://corpus-texmex.irisa.fr/.

    :returns ndarray:
        a N x D array, where N is the number of observations
        and D is the number of features
    """
    import os
    import struct

    format_code, format_size, py_type = {
        'f': ('f', 4, float),
        'i': ('I', 4, int),
        'b': ('B', 1, float)
    }[base_type]

    size = os.path.getsize(filename)

    f = open(filename, 'rb')
    D = np.uint32(struct.unpack('I', f.read(4))[0])
    N = size / (4 + D * format_size)

    if max_num is None:
        max_num = N

    f.seek(0)
    A = np.zeros((max_num, D), dtype=py_type)
    for i in xrange(max_num):
        for j in xrange(D + 1):
            if j == 0:
                np.uint32(struct.unpack(format_code, f.read(4)))
            else:
                A[i, j - 1] = py_type(struct.unpack(format_code, f.read(format_size))[0])
    f.close()
    return np.squeeze(A)

def gen_equal_splitting(d, n_split):
    """
        Generate a vector containing splitting points for product quantization
        :param d: dimension of data
        :param n_split: number of subsets to split
    """
    split_points = []
    split_dim = np.floor(d/n_split).astype(np.int32)    
    for i in range(n_split-1):
        split_points += [split_dim*(i+1)]

    return split_points

def unit_vector(X):
    return X/np.linalg.norm(X)

def vectorAngle(u, v):
    u1 = unit_vector(u)
    v1 = unit_vector(v)
    return np.arccos(np.clip(np.dot(u1, v1), -1.0, 1.0))

def distanceMatrix(X):
    """
    Compute distance matrix (for spectral clustering)

    """
    N = X.shape[0]
    
    Y = np.zeros(shape=(N, N))

    for i in range(N):                    
        for j in range(i+1, N):            
            #Y[i,j] =  vectorAngle(X[i,:], X[j,:])# np.linalg.norm(X[i,:] - X[j,:])
            Y[i,j] = np.linalg.norm(X[i,:] - X[j,:])
            Y[j,i] = Y[i,j]
    
    return Y

        

if __name__ == '__main__':
    
    print ('This file contains necessary utils')
    print ('Testing co-prime factorization')
